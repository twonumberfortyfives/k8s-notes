![[master-node]]
# Master Node (Control Plane)

**Main responsibility:** контролирует кластер, решает на каких Worker Node запускать Pods и делает health-check.

---

## kube-apiserver

- Отвечает за **приём и валидацию всех запросов** внутри и снаружи кластера.
    
- Примеры: команды `kubectl` снаружи, коммуникация между Worker Node через API Server.
    
- **Функции:**
    
    - Проверка аутентификации и авторизации (RBAC, токены, сертификаты)
        
    - Валидация и регистрация объектов
        
    - Чтение и запись данных в **etcd**
        
- **Важно:** никто не обращается к etcd напрямую — только через kube-apiserver.
    

---

## kube-scheduler

- Получает через kube-apiserver все **Pending Pods**.
    
- Анализирует доступные Worker Nodes и их ресурсы (CPU, RAM, etc.).
    
- Выбирает оптимальную ноду для Pod и сообщает через kube-apiserver.
    

---

## kube-controller-manager

- Постоянно проверяет **состояние объектов кластера** через kube-apiserver.
    
- Сравнивает **desired state** и **current state** Pod’ов.
    
- При расхождении инициирует действия через kube-apiserver для синхронизации состояния в etcd.
    

---

## etcd

- Хранилище **состояний кластера** (desired/actual state объектов).
    
- Не хранит контейнеры или их данные, только Kubernetes Objects.
    
- **Единственный источник истины** для управления кластером.
    
- **Доступ только через kube-apiserver.**
    

---

## kubelet

- На каждой Worker Node.
    
- Делает **WATCH-запросы через kube-apiserver** для отслеживания состояния Pod’ов.
    
- Если Pod упал или нужно создать новый:
    
    - Запускает/удаляет контейнеры через **container runtime**
        
    - Отправляет актуальный статус обратно в API Server
        

---

## kube-proxy

- **Сетевой агент** на каждой Worker Node (иногда на Master Node для системных Pod’ов).
    
- **Задачи:**
    
    - Маршрутизация трафика между Pod’ами через **Services**
        
    - Поддержание актуальной информации о живых Pod’ах (IP/port) через **WATCH на API Server**
        
- **Как работает:**
    
    1. Получает Endpoints (живые Pod’ы) через API Server
        
    2. При запросе контейнера на Service IP, kube-proxy **перехватывает запрос** и перенаправляет его на живой Pod напрямую
        
- **Важно:** API Server участвует только в синхронизации, не в каждом запросе Pod → Pod
    

---

## Container Runtime

- Реализует **CRI (Container Runtime Interface)**.
    
- kubelet через CRI управляет контейнерами:
    
    - Создание / запуск Pod’ов
        
    - Остановка / удаление контейнеров
        
- Примеры: Docker, containerd, CRI-O
## Cloud Controller Manager (CCM)

- **Назначение:** интеграция Kubernetes с облачными провайдерами (AWS, GCP, Azure и др.).
    
- **Где работает:** отдельный процесс на Master Node / Control Plane.
    
- **Функции:**
    
    - **Node Controller:** следит за состоянием нод, сообщает о недоступных нодах
        
    - **Route Controller:** настраивает маршрутизацию (routes) в облачной сети
        
    - **Service Controller:** создаёт облачные load balancer для Services типа `LoadBalancer`
        
    - **Volume Controller:** управляет облачными дисками и их монтированием к Pod’ам
        
- **Особенность:** все действия проходят через **API Server**, чтобы синхронизировать состояние кластера
    
- **Простая аналогия:** мост между Kubernetes и облаком для управления нодами, сетью, дисками и балансировкой нагрузки